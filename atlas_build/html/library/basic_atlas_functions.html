

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Built-In atlas Functions &mdash; atlas 0.6 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="atlas 0.6 documentation" href="../index.html"/>
        <link rel="up" title="atlas Library" href="../atlas_lib.html"/>
        <link rel="next" title="Source Code Library" href="../source_library.html"/>
        <link rel="prev" title="Basic Operators" href="operators.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> atlas
          

          
          </a>

          
            
            
              <div class="version">
                0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../gen_info.html">General Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial_with_examples.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../atlas_lib.html">atlas Library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">A Brief Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="axis.html">The Axis Language</a></li>
<li class="toctree-l2"><a class="reference internal" href="operators.html">Basic Operators</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Built-In <strong>atlas</strong> Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-functions">Basic Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#flex">flex</a></li>
<li class="toctree-l4"><a class="reference internal" href="#convolve">convolve</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stack-rows">stack_rows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error">error</a></li>
<li class="toctree-l4"><a class="reference internal" href="#int-format">int_format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#to-string">to_string</a></li>
<li class="toctree-l4"><a class="reference internal" href="#print">print</a></li>
<li class="toctree-l4"><a class="reference internal" href="#prints">prints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ascii">ascii</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ascii2">ascii</a></li>
<li class="toctree-l4"><a class="reference internal" href="#null">null</a></li>
<li class="toctree-l4"><a class="reference internal" href="#null2">null</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-manipulating-functions">Matrix Manipulating Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id-mat">id_mat</a></li>
<li class="toctree-l4"><a class="reference internal" href="#diagonal">diagonal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiss-matix-knife">swiss_matix_knife</a></li>
<li class="toctree-l4"><a class="reference internal" href="#echelon">echelon</a></li>
<li class="toctree-l4"><a class="reference internal" href="#diagonalize">diagonalize</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adapted-basis">adapted_basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel">kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#eigen-lattice">eigen_lattice</a></li>
<li class="toctree-l4"><a class="reference internal" href="#row-saturate">row_saturate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inv-fact">inv_fact</a></li>
<li class="toctree-l4"><a class="reference internal" href="#smith-basis">Smith_basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#smith">Smith</a></li>
<li class="toctree-l4"><a class="reference internal" href="#invert">invert</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mod2-section">mod2_section</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subspace-normal">subspace_normal</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#lie-group-basics">Lie Group Basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lie-type">Lie_type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lie-type2">Lie_type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cartan-matrix">Cartan_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cartan-matrix2">Cartan_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cartan-matrix-type">Cartan_matrix_type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rank">rank</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semisimple-rank">semisimple_rank</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operator">#</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id35">%</a></li>
<li class="toctree-l4"><a class="reference internal" href="#smith-cartan">Smith_Cartan</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filter-units">filter_units</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ann-mod">ann_mod</a></li>
<li class="toctree-l4"><a class="reference internal" href="#replace-gen">replace_gen</a></li>
<li class="toctree-l4"><a class="reference internal" href="#involution">involution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#involution2">involution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#root-datum">root_datum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#root-datum2">root_datum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#root-datum3">root_datum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#root-datum4">root_datum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quotient-basis">quotient_basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simply-connected">simply_connected</a></li>
<li class="toctree-l4"><a class="reference internal" href="#adjoint">adjoint</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dual">dual</a></li>
<li class="toctree-l4"><a class="reference internal" href="#derived-info">derived_info</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mod-central-torus-info">mod_central_torus_info</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rank2">rank</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semisimple-rank2">semisimple_rank</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#roots-and-weights">Roots and Weights</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-roots">simple_roots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-coroots">simple_coroots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#posroots">posroots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#poscoroots">poscoroots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#roots">roots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coroots">coroots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#root-coradical">root_coradical</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coroot-radical">coroot_radical</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fundamental-weight">fundamental_weight</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fundamental-coweight">fundamental_coweight</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nr-of-posroots">nr_of_posroots</a></li>
<li class="toctree-l4"><a class="reference internal" href="#root-index">root_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coroot-index">coroot_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integrality-datum">integrality_datum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integrality-points">integrality_points</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#more-advanced-functions">More Advanced Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#classify-involution">classify_involution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inner-class">inner_class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#twisted-involution">twisted_involution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inner-class2">inner_class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inner-class3">inner_class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id75">=</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nr-of-real-forms">nr_of_real_forms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nr-of-dual-real-forms">nr_of_dual_real_forms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nr-of-cartan-classes">nr_of_Cartan_classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-sizes">block_sizes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#form-names">form_names</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dual-form-names">dual_form_names</a></li>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-matrix">occurrence_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dual-occurrence-matrix">dual_occurrence_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real-form">real_form</a></li>
<li class="toctree-l4"><a class="reference internal" href="#form-number">form_number</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quasisplit-form">quasisplit_form</a></li>
<li class="toctree-l4"><a class="reference internal" href="#components-rank">components_rank</a></li>
<li class="toctree-l4"><a class="reference internal" href="#count-cartans">count_Cartans</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operator-2">=</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kgb-size">KGB_size</a></li>
<li class="toctree-l4"><a class="reference internal" href="#base-grading-vector">base_grading_vector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cartan-order">Cartan_order</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dual-real-form">dual_real_form</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dual-quasisplit-form">dual_quasisplit_form</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cartan-class">Cartan_class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cartan-class2">Cartan_class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#most-split-cartan">most_split_Cartan</a></li>
<li class="toctree-l4"><a class="reference internal" href="#involution3">involution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cartan-info">Cartan_info</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real-forms">real_forms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dual-real-forms">dual_real_forms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#square-classes">square_classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fiber-partition">fiber_partition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#real-form2">real_form</a></li>
<li class="toctree-l4"><a class="reference internal" href="#central-fiber">central_fiber</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initial-torus-bits">initial_torus_bits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kgb">KGB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id108">%</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id110">Cartan_class</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../source_library.html">Source Code Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../videos.html">Videos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trouble_shooting.html">Trouble Shooting</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">atlas</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../atlas_lib.html">atlas Library</a> &raquo;</li>
      
    <li>Built-In <strong>atlas</strong> Functions</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/library/basic_atlas_functions.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="built-in-atlas-functions">
<h1>Built-In <strong>atlas</strong> Functions<a class="headerlink" href="#built-in-atlas-functions" title="Permalink to this headline">¶</a></h1>
<p>Built-in functions are those functions that are available before you load any <code class="docutils literal"><span class="pre">.at</span></code> files.</p>
<div class="section" id="basic-functions">
<h2>Basic Functions<a class="headerlink" href="#basic-functions" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Argument(s) -&gt; Result(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#flex"><span>flex_add, flex_sub</span></a></td>
<td><code class="docutils literal"><span class="pre">(vec,vec-&gt;vec)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#convolve"><span>convolve</span></a></td>
<td><code class="docutils literal"><span class="pre">(vec,vec-&gt;vec)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#stack-rows"><span>stack_rows</span></a></td>
<td><code class="docutils literal"><span class="pre">([vec]-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#error"><span>error</span></a></td>
<td><code class="docutils literal"><span class="pre">(*,...-&gt;*)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#int-format"><span>int_format</span></a></td>
<td><code class="docutils literal"><span class="pre">(int-&gt;string)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#to-string"><span>to_string</span></a></td>
<td><code class="docutils literal"><span class="pre">(*,...-&gt;string)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#print"><span>print</span></a></td>
<td><code class="docutils literal"><span class="pre">(T-&gt;T)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#prints"><span>prints</span></a></td>
<td><code class="docutils literal"><span class="pre">(*,...-&gt;)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ascii"><span>ascii</span></a></td>
<td><code class="docutils literal"><span class="pre">(string-&gt;int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ascii2"><span>ascii</span></a></td>
<td><code class="docutils literal"><span class="pre">(int-&gt;string)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#null"><span>null</span></a></td>
<td><code class="docutils literal"><span class="pre">(int-&gt;vec)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#null2"><span>null</span></a></td>
<td><code class="docutils literal"><span class="pre">(int,int-&gt;mat)</span></code></td>
</tr>
</tbody>
</table>
<div class="section" id="flex">
<span id="id1"></span><h3>flex<a class="headerlink" href="#flex" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">flex_add</span></code> and <code class="docutils literal"><span class="pre">flex_sub</span></code> are variants of <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code> adding/removing trailing 0&#8217;s.</div></blockquote>
</div>
<div class="section" id="convolve">
<span id="id2"></span><h3>convolve<a class="headerlink" href="#convolve" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">convolve</span></code> produce convolution product of vectors, removing trailing 0&#8217;s.</div></blockquote>
</div>
<div class="section" id="stack-rows">
<span id="id3"></span><h3>stack_rows<a class="headerlink" href="#stack-rows" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">stack_rows</span></code> combine ragged rows into matrix, zero-extend shorts.</div></blockquote>
</div>
<div class="section" id="error">
<span id="id4"></span><h3>error<a class="headerlink" href="#error" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">error</span></code> print values and abort computation; report a runtime error.</div></blockquote>
</div>
<div class="section" id="int-format">
<span id="id5"></span><h3>int_format<a class="headerlink" href="#int-format" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(int-&gt;string)</span></code>: representation of integer as digit string.</div></blockquote>
</div>
<div class="section" id="to-string">
<span id="id6"></span><h3>to_string<a class="headerlink" href="#to-string" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(*,...-&gt;string)</span></code>: string representation of arguments (concatenated).</div></blockquote>
</div>
<div class="section" id="print">
<span id="id7"></span><h3>print<a class="headerlink" href="#print" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(T-&gt;T)</span></code>: print value, followed by newline; return same value.</div></blockquote>
</div>
<div class="section" id="prints">
<span id="id8"></span><h3>prints<a class="headerlink" href="#prints" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(*,...-&gt;)</span></code>: print values raw (no quotes or commas) followed by newline.</div></blockquote>
</div>
<div class="section" id="ascii">
<span id="id9"></span><h3>ascii<a class="headerlink" href="#ascii" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(string-&gt;int)</span></code>: ASCII code of initial character, or -1 if string empty</div></blockquote>
</div>
<div class="section" id="ascii2">
<span id="id10"></span><h3>ascii<a class="headerlink" href="#ascii2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(int-&gt;string)</span></code>: string of length 1 with given ASCII code (if safe value).</div></blockquote>
</div>
<div class="section" id="null">
<span id="id11"></span><h3>null<a class="headerlink" href="#null" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(int-&gt;vec)</span></code>: null vector of given length.</div></blockquote>
</div>
<div class="section" id="null2">
<span id="id12"></span><h3>null<a class="headerlink" href="#null2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(int,int-&gt;mat)</span></code>: null matrix with given number of rows and columns.</div></blockquote>
</div>
</div>
<div class="section" id="matrix-manipulating-functions">
<h2>Matrix Manipulating Functions<a class="headerlink" href="#matrix-manipulating-functions" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Argument(s) -&gt; Result(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#id-mat"><span>id_mat</span></a></td>
<td><code class="docutils literal"><span class="pre">(int-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#diagonal"><span>diagonal</span></a></td>
<td><code class="docutils literal"><span class="pre">(vec-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#swiss-matrix-knife"><span>swiss_matix_knife</span></a></td>
<td><code class="docutils literal"><span class="pre">(int,mat,int,int,int,int-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#echelon"><span>echelon</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat,[int])</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#diagonalize"><span>diagonalize</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;vec,mat,mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#adapted-basis"><span>adapted_basis</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat,vec)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#kernel"><span>kernel</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#eigen-lattice"><span>eigen_lattice</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat,int-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#row-saturate"><span>row_saturate</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#inv-fact"><span>inv_fact</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;vec)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#smith-basis"><span>Smith_basis</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#smith"><span>Smith</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat,vec)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#invert"><span>invert</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat,int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mod2-section"><span>mod2_section</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#subspace-normal"><span>subspace_normal</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;mat,mat,mat,[int])</span></code></td>
</tr>
</tbody>
</table>
<div class="section" id="id-mat">
<span id="id13"></span><h3>id_mat<a class="headerlink" href="#id-mat" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(int-&gt;mat)</span></code>: identity matrix of given size.</div></blockquote>
</div>
<div class="section" id="diagonal">
<span id="id14"></span><h3>diagonal<a class="headerlink" href="#diagonal" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(vec-&gt;mat)</span></code>: square diagonal matrix with given diagonal entries.</div></blockquote>
</div>
<div class="section" id="swiss-matix-knife">
<span id="swiss-matrix-knife"></span><h3>swiss_matix_knife<a class="headerlink" href="#swiss-matix-knife" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(int,mat,int,int,int,int-&gt;mat)</span></code>: slice and dice a matrix.</p>
<p>This function selects a block from a matrix, and depending on the options in its first argument can apply a number of transformations on the fly. The basic call <code class="docutils literal"><span class="pre">swiss_matrix_knife(0,A,i,k,j,l)</span></code> returns the block <code class="docutils literal"><span class="pre">A[i:k,j:l]</span></code> (and is in fact used behind the scenes to implement that syntax). The first (integer) argument specifies 8 options (its value is taken modulo 2^8=256) as follows. Bits 0,1,2 modify row indexing: setting bit 0 reverses the rows before selecting, and bits 1,2 when set specify that i respectively k count from the end (they are subtracted from the number of rows before being used). Similarly bits 3,4,5 modify column indexing. Bit 6 when set specifies that the resulting block is transposed, and bit 7 when set indicates that all entries of the resulting matrix are negated (they are multiplied by -1).</p>
</div></blockquote>
</div>
<div class="section" id="echelon">
<span id="id15"></span><h3>echelon<a class="headerlink" href="#echelon" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;mat,[int])</span></code>: make column echelon form, and return pivots as well.</p>
<p>This applies column operations, and possibly removal of null columns; the number of remaining columns is the rank. The result is a pair <code class="docutils literal"><span class="pre">(M,s)</span></code> with s increasing sequence, and <code class="docutils literal"><span class="pre">M[i,j]</span></code> is nonzero for <code class="docutils literal"><span class="pre">i=s[j]</span></code> and zero for <code class="docutils literal"><span class="pre">i&gt;s[j]</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="diagonalize">
<span id="id16"></span><h3>diagonalize<a class="headerlink" href="#diagonalize" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;vec,mat,mat)</span></code>: partial Smith reduction, without divisibility.</p>
<p>Applies row and column operations to the matrix to obtain diagonal form; returns the list of non-zero diagonal entries (all except the first are assured to be positive), and the pair of determinant 1 integral matrices that have been applied to left and right respectively.</p>
</div></blockquote>
</div>
<div class="section" id="adapted-basis">
<span id="id17"></span><h3>adapted_basis<a class="headerlink" href="#adapted-basis" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;mat,vec)</span></code>: find basis whose integer multiples span image.</p>
<p>Returns for <code class="docutils literal"><span class="pre">M</span></code> a pair <code class="docutils literal"><span class="pre">(B,c)</span></code> of a basis (columns of <code class="docutils literal"><span class="pre">B</span></code>) and matching list <code class="docutils literal"><span class="pre">c</span></code> of
positive integers, such that the column span of <code class="docutils literal"><span class="pre">M</span></code> is the same as the span of
the multiples <code class="docutils literal"><span class="pre">c_j*B_j</span></code> of the columns <code class="docutils literal"><span class="pre">B_j</span></code> of the matrix <code class="docutils literal"><span class="pre">B</span></code> by the scalars <code class="docutils literal"><span class="pre">c_j</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="kernel">
<span id="id18"></span><h3>kernel<a class="headerlink" href="#kernel" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(mat-&gt;mat)</span></code>: find matrix whose columns span kernel of the given matrix.</div></blockquote>
</div>
<div class="section" id="eigen-lattice">
<span id="id19"></span><h3>eigen_lattice<a class="headerlink" href="#eigen-lattice" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat,int-&gt;mat)</span></code>: eigen-lattice of matrix (at integer eigenvalue).</p>
<p><code class="docutils literal"><span class="pre">eigen_lattice(M,lambda)</span></code> = <code class="docutils literal"><span class="pre">kernel(M-lambda*id_mat(n))</span></code>, where <code class="docutils literal"><span class="pre">#M=(n,n)</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="row-saturate">
<span id="id20"></span><h3>row_saturate<a class="headerlink" href="#row-saturate" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;mat)</span></code>: keep same kernel, but row-span saturated sublattice</p>
<p>Interpreting rows of the matrix as linear forms, this transforms the system into an equivalent one, and whose Z-linear map is made to be surjective. In other words, the rows are made linearly independent, and the sublattice they generate saturated: if an integer multiple of v is in it, then so is v.</p>
</div></blockquote>
</div>
<div class="section" id="inv-fact">
<span id="id21"></span><h3>inv_fact<a class="headerlink" href="#inv-fact" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(mat-&gt;vec)</span></code>: invariant factors in Smith normal form (no zeros).</div></blockquote>
</div>
<div class="section" id="smith-basis">
<span id="id22"></span><h3>Smith_basis<a class="headerlink" href="#smith-basis" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(mat-&gt;mat)</span></code>: a basis on which the Smith normal form is assumed.</div></blockquote>
</div>
<div class="section" id="smith">
<span id="id23"></span><h3>Smith<a class="headerlink" href="#smith" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(mat-&gt;mat,vec)</span></code>: <code class="docutils literal"><span class="pre">Smith(M)</span></code> = <code class="docutils literal"><span class="pre">(</span> <span class="pre">Smith_basis(M),</span> <span class="pre">inv_fact(M)</span> <span class="pre">)</span></code> (almost). <code class="docutils literal"><span class="pre">Smith(M)</span></code> describes explicitly the sublattice spanned by the columns of M. The first component is an invertible matrix, whose columns, multiplied by the corresponding entries of the second component, span that sublattice. <code class="docutils literal"><span class="pre">inv_fact(M)</span></code> is the list of the invariant factors of M, which are like the second component of <code class="docutils literal"><span class="pre">adpted_basis(M)</span></code>, but with additional requirement that each entry divides the next; this may involve using a different basis. Smith_basis(M) is that basis corresponding to <code class="docutils literal"><span class="pre">inv_fact(M)</span></code>, an invertible (over Z) square matrix equal in height to M, whose columns, each multiplied by the corresponding invariant factor (or 0), span the same as those of M.</div></blockquote>
</div>
<div class="section" id="invert">
<span id="id24"></span><h3>invert<a class="headerlink" href="#invert" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;mat,int)</span></code>: <code class="docutils literal"><span class="pre">invert(M)</span></code> produces <code class="docutils literal"><span class="pre">(inv,</span> <span class="pre">d)</span></code> such that <span class="math">\(M \cdot inv=d \cdot Id\)</span>, with d minimal.</p>
<p>The inverse matrix, represented as an integral numerator matrix inv, and a minimal positive common denominator d. Note: d does not mean determinant.</p>
</div></blockquote>
</div>
<div class="section" id="mod2-section">
<span id="id25"></span><h3>mod2_section<a class="headerlink" href="#mod2-section" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;mat)</span></code>: find section (left/right/inverse) of binary matrix</p>
<p>The argument is reduced modulo 2 to a matrix A over <span class="math">\(\mathbb{Z}/2\mathbb{Z}\)</span>; it returns a matrix <span class="math">\(B\)</span> such that <span class="math">\(ABA=A\)</span> and <span class="math">\(BAB=B\)</span>; it will be an inverse/left inverse/right inverse of (over <span class="math">\(\mathbb{Z}/2\mathbb{Z}\)</span>) whenever <span class="math">\(A\)</span> is bijective/surjective/injective.</p>
</div></blockquote>
</div>
<div class="section" id="subspace-normal">
<span id="id26"></span><h3>subspace_normal<a class="headerlink" href="#subspace-normal" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;mat,mat,mat,[int])</span></code>: normalized modulo-2 basis.</p>
<p>Given a sequence of binary vectors, namely the reduction modulo 2 of the columns of the argument matrix, find a normalized basis for the subspace they span (a matrix in reduced column echelon form without zero columns), and also expressions for the basis vectors in terms of the given list, a basis for the relations between the vectors, and a list of pivot values (each list given as a matrix with the specified vectors as its columns). The argument is a list of n generators of size r whose components are interpreted modulo 2, the first output component is a reduced echelon basis, consisting of d binary vectors of size r where d is the dimension of the subspace, the next component has d binary vectors of size n, giving the combination of generators that produced this basis vector, the next component has n-d binary vectors of size n, each giving basis of the linear dependency relations among the generators, and the final component is an increasing sequence of nonnegative d integers less than r giving the pivot positions, the first nonzero positions in each of the basis vectors.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="lie-group-basics">
<h2>Lie Group Basics<a class="headerlink" href="#lie-group-basics" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Argument(s) -&gt; Result(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#lie-type"><span>Lie_type</span></a></td>
<td><code class="docutils literal"><span class="pre">(string-&gt;LieType)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#lie-type2"><span>Lie_type</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;LieType)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cartan-matrix"><span>Cartan_matrix</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cartan-matrix2"><span>Cartan_matrix</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cartan-matrix-type"><span>Cartan_matrix_type</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;LieType,vec)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#rank"><span>rank</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType-&gt;int)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#semisimple-rank"><span>semisimple_rank</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType-&gt;int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#operator"><span>#</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType-&gt;int)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#id35"><span>%</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType-&gt;[LieType])</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#smith-cartan"><span>Smith_Cartan</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType-&gt;mat,vec)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#filter-units"><span>filter_units</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat,vec-&gt;mat,vec)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ann-mod"><span>ann_mod</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat,int-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#replace-gen"><span>replace_gen</span></a></td>
<td><code class="docutils literal"><span class="pre">((mat,vec),mat-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#involution"><span>involution</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType,string-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#involution2"><span>involution</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType,mat,string-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#root-datum"><span>root_datum</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat,mat-&gt;RootDatum)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#root-datum2"><span>root_datum</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType,mat-&gt;RootDatum)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#root-datum3"><span>root_datum</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum,mat-&gt;RootDatum)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#root-datum4"><span>root_datum</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;RootDatum)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quotient-basis"><span>quotient_basis</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType,[ratvec]-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#simply-connected"><span>simply_connected</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType-&gt;RootDatum)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#adjoint"><span>adjoint</span></a></td>
<td><code class="docutils literal"><span class="pre">(LieType-&gt;RootDatum)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dual"><span>dual</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;RootDatum)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#derived-info"><span>derived_info</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;RootDatum,mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mod-central-torus-info"><span>mod_central_torus_info</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;RootDatum,mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#rank2"><span>rank</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;int)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#semisimple-rank2"><span>semisimple_rank</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;int)</span></code></td>
</tr>
</tbody>
</table>
<div class="section" id="lie-type">
<span id="id27"></span><h3>Lie_type<a class="headerlink" href="#lie-type" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(string-&gt;LieType)</span></code>: interpret string as Lie type.</p>
<p>Factors are one of &#8220;ABCDEFGT&#8221; followed by a number; several factors can be concatenated in a string with optional punctuation. Must have total rank&lt;=16.</p>
</div></blockquote>
</div>
<div class="section" id="lie-type2">
<span id="id28"></span><h3>Lie_type<a class="headerlink" href="#lie-type2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;LieType)</span></code>: Lie type of a root datum.</div></blockquote>
</div>
<div class="section" id="cartan-matrix">
<span id="id29"></span><h3>Cartan_matrix<a class="headerlink" href="#cartan-matrix" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(LieType-&gt;mat)</span></code>: Cartan matrix of Lie type (square of size rank).</p>
<p>A block form Cartan matrix, with zeros in rows and columns of torus factors</p>
</div></blockquote>
</div>
<div class="section" id="cartan-matrix2">
<span id="id30"></span><h3>Cartan_matrix<a class="headerlink" href="#cartan-matrix2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: Cartan matrix of root datum.</p>
<p>This pairs roots and coroots, so it is square, of size the semisimple rank. By force of convention, rows correspond to roots and columns to coroots.</p>
</div></blockquote>
</div>
<div class="section" id="cartan-matrix-type">
<span id="id31"></span><h3>Cartan_matrix_type<a class="headerlink" href="#cartan-matrix-type" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;LieType,vec)</span></code>: type given by Cartan matrix.</p>
<p>The input should be a Cartan matrix for a semisimple type (no zero rows or columns). The function returns the semisimple type, and the permutation of mapping the standard (Bourbaki) ordering of the diagram of that type to the ordering of the corresponding simple roots in matrix rows and columns.</p>
</div></blockquote>
</div>
<div class="section" id="rank">
<span id="id32"></span><h3>rank<a class="headerlink" href="#rank" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(LieType-&gt;int)</span></code>: Rank of the weight lattice for this Lie type.</div></blockquote>
</div>
<div class="section" id="semisimple-rank">
<span id="id33"></span><h3>semisimple_rank<a class="headerlink" href="#semisimple-rank" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(LieType-&gt;int)</span></code>: Rank of the root lattice of this Lie type.</div></blockquote>
</div>
<div class="section" id="operator">
<span id="id34"></span><h3>#<a class="headerlink" href="#operator" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(LieType-&gt;int)</span></code>: Number of (simple or T1) factors in this Lie type</div></blockquote>
</div>
<div class="section" id="id35">
<span id="id36"></span><h3>%<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(LieType-&gt;[LieType])</span></code>: Expand into row of simple factors (or T1)</div></blockquote>
</div>
<div class="section" id="smith-cartan">
<span id="id37"></span><h3>Smith_Cartan<a class="headerlink" href="#smith-cartan" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(LieType-&gt;mat,vec)</span></code>: generators of weights modulo roots.</p>
<p>Find a Smith basis for the weight lattice relative to the sublattice of roots, with corresponding invariant factors. It is almost equivalent to <code class="docutils literal"><span class="pre">Smith(^Cartan_matrix(type))</span></code>, except that
(1). Smith_Cartan produces a separate diagonal block for each simple or torus factor,
(2). for factors <code class="docutils literal"><span class="pre">T</span></code> of the Lie type, <code class="docutils literal"><span class="pre">Smith_Cartan</span></code> produces a column with just &#8216;1&#8217; on the diagonal, but with corresponding &#8220;invariant factor&#8221; set equal to &#8216;0&#8217;, and
(3). for factors <span class="math">\(D_{2n}\)</span> an equivalent basis is given, which has been tweaked so that the final two vectors are standard basis vectors.</p>
</div></blockquote>
</div>
<div class="section" id="filter-units">
<span id="id38"></span><h3>filter_units<a class="headerlink" href="#filter-units" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat,vec-&gt;mat,vec)</span></code>: discard entries &#8216;1&#8217; and their columns.</p>
<p>The input is presumably produced by <code class="docutils literal"><span class="pre">Smith_Cartan</span></code> or <code class="docutils literal"><span class="pre">adapted_basis</span></code>; for all positions where the second (vector) component has &#8216;1&#8217;, that entry and the corresponding column of the first matrix is discarded; what is left of the matrix and the vector is returned. If the vector has fewer entries than the matrix has columns (cf. <code class="docutils literal"><span class="pre">adapted_basis</span></code>), missing entries count as not 1.</p>
</div></blockquote>
</div>
<div class="section" id="ann-mod">
<span id="id39"></span><h3>ann_mod<a class="headerlink" href="#ann-mod" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat,int-&gt;mat)</span></code>: find maximal matrix with product divisible by d.</p>
<p>The call <code class="docutils literal"><span class="pre">ann_mod(M,d)</span></code> finds a square matrix A whose columns have the same height as those of M and span a maximal sublattice subject to the condition that the scalar product of every column of A with every column of M is divisible by d (the matrix product <code class="docutils literal"><span class="pre">^A*M</span></code> vanishes modulo d).</p>
</div></blockquote>
</div>
<div class="section" id="replace-gen">
<span id="id40"></span><h3>replace_gen<a class="headerlink" href="#replace-gen" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">((mat,vec),mat-&gt;mat)</span></code>: replace generators of weight lattice.</p>
<p>The arguments are as for <code class="docutils literal"><span class="pre">filter_units</span></code>. For every entry different from &#8216;1&#8217; in the vector argument, replace a column from the first matrix by a column from the second matrix. Both matrices must have the same column size; like for <code class="docutils literal"><span class="pre">filter_units</span></code> the vector may be short, missing entries being not 1.</p>
</div></blockquote>
</div>
<div class="section" id="involution">
<span id="id41"></span><h3>involution<a class="headerlink" href="#involution" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(LieType,string-&gt;mat)</span></code>: diagram involution for inner class.</p>
<p>Return an involution matrix corresponding to the diagram involution described symbolically by the string, which is interpreted as the inner class string is in the Atlas, where &#8216;e&#8217; or &#8216;c&#8217; mean compact (equal rank), &#8216;u&#8217; means unequal rank (for types <span class="math">\(A_n\)</span> with <span class="math">\(n&gt;1\)</span>, <span class="math">\(D_n\)</span> and <span class="math">\(E_6\)</span>), &#8216;s&#8217; means split and &#8216;C&#8217; means Complex. This is essentially a permutation matrix, except that for the split type on torus factors there is a diagonal entry -1</p>
</div></blockquote>
</div>
<div class="section" id="involution2">
<span id="id42"></span><h3>involution<a class="headerlink" href="#involution2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(LieType,mat,string-&gt;mat)</span></code>: basic involution on given basis.</p>
<p>This is like previous &#8216;involution&#8217; for the same Lie type and inner class string, but the involution matrix is now expressed the given basis given by the columns of the matrix specified as second argument; this expression must be possible, so the sublattice spanned should be stable under the involution.</p>
</div></blockquote>
</div>
<div class="section" id="root-datum">
<span id="id43"></span><h3>root_datum<a class="headerlink" href="#root-datum" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat,mat-&gt;RootDatum)</span></code>: root datum from simple (co)root systems.</p>
<p>In <code class="docutils literal"><span class="pre">root_datum(roots,coroots)</span></code>, matrices roots and coroots must have the same dimensions (rank x semisimple rank); their columns give the desired systems of simple roots respectively simple coroots. The matrix of pairings of roots and coroots should be a valid Cartan matrix. A root datum with those systems of simple roots and simple coroots is returned.</p>
</div></blockquote>
</div>
<div class="section" id="root-datum2">
<span id="id44"></span><h3>root_datum<a class="headerlink" href="#root-datum2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(LieType,mat-&gt;RootDatum)</span></code>: root datum for given type and sublattice.</p>
<p>The columns of the matrix argument are interpreted as specifying the basis of a sublattice of the character lattice of the &#8220;simply connected&#8221; group G of the given Lie type (which is a direct product of a simply connected semisimple group G&#8217; and a central torus S), expressed in the basis of fundamental weights of G&#8217; and an arbitrary basis for characters of S). For this to be possible, it is required that the sublattice contain the root lattice of G&#8217;. The sublattice becomes the standard lattice for working with the root datum, and is identified with Z^n using the given basis, which thus becomes the standard basis of the sublattice, henceforth called lattice.</p>
</div></blockquote>
</div>
<div class="section" id="root-datum3">
<span id="id45"></span><h3>root_datum<a class="headerlink" href="#root-datum3" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum,mat-&gt;RootDatum)</span></code>: root datum for sublattice in old one</p>
<p>This is like root_datum&#64;(LieType,mat), but starting from the specified root datum rd rather than from the simply connected one for the Lie type. The provided sublattice matrix must be square and full rank (invertible of the rational numbers) and the roots of rd must be in its integral column span.</p>
</div></blockquote>
</div>
<div class="section" id="root-datum4">
<span id="id46"></span><h3>root_datum<a class="headerlink" href="#root-datum4" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass-&gt;RootDatum)</span></code>: root datum of inner class.</p>
<p>Extract the root datum from the <code class="docutils literal"><span class="pre">InnerClass</span></code> value.</p>
</div></blockquote>
</div>
<div class="section" id="quotient-basis">
<span id="id47"></span><h3>quotient_basis<a class="headerlink" href="#quotient-basis" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">(LieType,[ratvec]-&gt;mat)</span></code>: sublattice given by kernel generators.</p>
<blockquote>
<div>Interpret the rational vectors as kernel generators for the given type, as in the atlas program, and return the corresponding sublattice as a matrix whose column are its generators. More precisely, the rational vectors represent linear combinations of certain coweights in the dual basis to a basis of the weight lattice adapted to the root lattice; for those weights in the latter basis that already lie in the root lattice, the corresponding coweight is omitted, since there are no useful rational multiples of it anyway. Return a basis for the sublattice of <span class="math">\(X^{\*}\)</span> of weights on which all kernel generators have integer evaluation. If M is the matrix whose columns are the numerators of the kernel generators, brought to a common denominator d, this amounts to setting <code class="docutils literal"><span class="pre">S=Smith_Cartan(type)</span></code> and <code class="docutils literal"><span class="pre">(C,)=filter_units(S)</span></code>, and then returning the value <code class="docutils literal"><span class="pre">replace_gen(S,C\*ann_mod(M,d))</span></code>. This function is intended for use in constructing root data; see basic.at</div></blockquote>
</div>
<div class="section" id="simply-connected">
<span id="id48"></span><h3>simply_connected<a class="headerlink" href="#simply-connected" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(LieType-&gt;RootDatum)</span></code>: simply connected datum for given type.</p>
<p>This gives the root datum for the &#8220;simply connected&#8221; group of the given type (the direct product of a simply conneted G&#8217; with a central torus): <code class="docutils literal"><span class="pre">set</span> <span class="pre">simply_connected_datum(LieType</span> <span class="pre">type)</span> <span class="pre">=</span> <span class="pre">root_datum(type,id_mat(rank))</span></code></p>
</div></blockquote>
</div>
<div class="section" id="adjoint">
<span id="id49"></span><h3>adjoint<a class="headerlink" href="#adjoint" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(LieType-&gt;RootDatum)</span></code>: adjoint root datum for given type.
Here the sublattice for the semisimple factor is the root lattice, with simple roots as basis; for the central torus an arbitrary basis is used. Therefore the this function could be defined as</div></blockquote>
<div class="highlight-python"><div class="highlight"><pre><span></span>set adjoint_datum(LieType type) =
let M= for alpha@j in ^Cartan_matrix(type)
       do for entry@i in alpha
          do if i=j and entry=0 then 1 else entry fi
          od
       od
in root_datum(type,M)
</pre></div>
</div>
</div>
<div class="section" id="dual">
<span id="id50"></span><h3>dual<a class="headerlink" href="#dual" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;RootDatum)</span></code>: dual of given root datum.</div></blockquote>
</div>
<div class="section" id="derived-info">
<span id="id51"></span><h3>derived_info<a class="headerlink" href="#derived-info" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum-&gt;RootDatum,mat)</span></code>: information for the derived group.</p>
<p>The first result is the root datum for the derived group itself, the second result is a matrix mapping weights from the original to the derived datum.</p>
</div></blockquote>
</div>
<div class="section" id="mod-central-torus-info">
<span id="id52"></span><h3>mod_central_torus_info<a class="headerlink" href="#mod-central-torus-info" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum-&gt;RootDatum,mat)</span></code>: quotient by central torus.</p>
<p>The (semisimple) root datum obtained by quotienting by the central torus, and matrix embedding weights for the quotient datum into the original datum.</p>
</div></blockquote>
</div>
<div class="section" id="rank2">
<span id="id53"></span><h3>rank<a class="headerlink" href="#rank2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;int)</span></code>: Rank of the weight lattice for this Lie type.</div></blockquote>
</div>
<div class="section" id="semisimple-rank2">
<span id="id54"></span><h3>semisimple_rank<a class="headerlink" href="#semisimple-rank2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;int)</span></code>: Rank of the root lattice of  this Lie type.</div></blockquote>
</div>
</div>
<div class="section" id="roots-and-weights">
<h2>Roots and Weights<a class="headerlink" href="#roots-and-weights" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Argument(s) -&gt; Result(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#simple-roots"><span>simple_roots</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#simple-coroots"><span>simple_coroots</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#posroots"><span>posroots</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#poscoroots"><span>poscoroots</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#roots"><span>roots</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#coroots"><span>coroots</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#root-coradical"><span>root_coradical</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#coroot-radical"><span>coroot_radical</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#fundamental-weight"><span>fundamental_weight</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum,int-&gt;ratvec)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#fundamental-coweight"><span>fundamental_coweight</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum,int-&gt;ratvec)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nr-of-posroots"><span>nr_of_posroots</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#root-index"><span>root_index</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum-&gt;int)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#coroot-index"><span>coroot_index</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum,vec-&gt;int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#integrality-datum"><span>integrality_datum</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum,ratvec-&gt;RootDatum)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#integrality-points"><span>integrality_points</span></a></td>
<td><code class="docutils literal"><span class="pre">(Rootdatum,ratvec-&gt;[rat])</span></code></td>
</tr>
</tbody>
</table>
<div class="section" id="simple-roots">
<span id="id55"></span><h3>simple_roots<a class="headerlink" href="#simple-roots" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: matrix of simple roots in the root datum.</div></blockquote>
</div>
<div class="section" id="simple-coroots">
<span id="id56"></span><h3>simple_coroots<a class="headerlink" href="#simple-coroots" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: matrix of simple coroots in the root datum.</div></blockquote>
</div>
<div class="section" id="posroots">
<span id="id57"></span><h3>posroots<a class="headerlink" href="#posroots" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: matrix of positive roots in the root datum.</div></blockquote>
</div>
<div class="section" id="poscoroots">
<span id="id58"></span><h3>poscoroots<a class="headerlink" href="#poscoroots" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: matrix of positive coroots in the root datum.</div></blockquote>
</div>
<div class="section" id="roots">
<span id="id59"></span><h3>roots<a class="headerlink" href="#roots" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: set of roots in the root datum (columns of result).</div></blockquote>
</div>
<div class="section" id="coroots">
<span id="id60"></span><h3>coroots<a class="headerlink" href="#coroots" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: set of coroots in the root datum (as columns).</div></blockquote>
</div>
<div class="section" id="root-coradical">
<span id="id61"></span><h3>root_coradical<a class="headerlink" href="#root-coradical" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: simple roots and coradical basis.</p>
<p>With respect to simple_roots, add columns for coradical basis generators.</p>
</div></blockquote>
</div>
<div class="section" id="coroot-radical">
<span id="id62"></span><h3>coroot_radical<a class="headerlink" href="#coroot-radical" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum-&gt;mat)</span></code>: simple coroots and radical basis.</p>
<p>With respect to <code class="docutils literal"><span class="pre">simple_coroots</span></code>, add columns for radical basis generators.</p>
</div></blockquote>
</div>
<div class="section" id="fundamental-weight">
<span id="id63"></span><h3>fundamental_weight<a class="headerlink" href="#fundamental-weight" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum,int-&gt;ratvec)</span></code>: fundamental weight number <span class="math">\(i\)</span>.</div></blockquote>
</div>
<div class="section" id="fundamental-coweight">
<span id="id64"></span><h3>fundamental_coweight<a class="headerlink" href="#fundamental-coweight" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum,int-&gt;ratvec)</span></code>: fundamental coweight number <span class="math">\(i\)</span>.</div></blockquote>
</div>
<div class="section" id="nr-of-posroots">
<span id="id65"></span><h3>nr_of_posroots<a class="headerlink" href="#nr-of-posroots" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum-&gt;int)</span></code>: Number of positive roots in the root datum.</div></blockquote>
</div>
<div class="section" id="root-index">
<span id="id66"></span><h3>root_index<a class="headerlink" href="#root-index" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum,vec-&gt;int)</span></code>: Index of root with respect to posroots.</div></blockquote>
</div>
<div class="section" id="coroot-index">
<span id="id67"></span><h3>coroot_index<a class="headerlink" href="#coroot-index" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum,vec-&gt;int)</span></code>: Index of coroot with respect to poscoroots.</p>
<p>These functions look up the vector in <code class="docutils literal"><span class="pre">posroots(rd)</span></code> or <code class="docutils literal"><span class="pre">poscoroots(rd)</span></code>, and return the index found shifted down by <code class="docutils literal"><span class="pre">nr_of_posroots(rd)</span></code>, so that the simple roots start at 0, and negative roots give a negative result. In case the vector is not found at all, the value <code class="docutils literal"><span class="pre">nr_of_posroots(rd)</span></code> is returned.</p>
</div></blockquote>
</div>
<div class="section" id="integrality-datum">
<span id="id68"></span><h3>integrality_datum<a class="headerlink" href="#integrality-datum" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum,ratvec-&gt;RootDatum)</span></code>: integral coroots subdatum.</p>
<p>Applied to <code class="docutils literal"><span class="pre">(rd,gamma)</span></code>, forms the root datum whose coroots form the closed subsystem of the coroots of rd that take an integral value on gamma.</p>
</div></blockquote>
</div>
<div class="section" id="integrality-points">
<span id="id69"></span><h3>integrality_points<a class="headerlink" href="#integrality-points" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum,ratvec-&gt;[rat])</span></code>: fractions with integrality.</p>
<p>The call integrality_points(rd,lambda) returns the increasing list of positive fractions f&lt;=1 so f* lambda has more integrality than generically: for some coroot alphav one has integral and nonzero value <code class="docutils literal"><span class="pre">&lt;alphav,f*lambda&gt;</span></code>.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="more-advanced-functions">
<h2>More Advanced Functions<a class="headerlink" href="#more-advanced-functions" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Argument(s) -&gt; Result(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#classify-involution"><span>classify_involution</span></a></td>
<td><code class="docutils literal"><span class="pre">(mat-&gt;int,int,int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#inner-class"><span>inner_class</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum,mat-&gt;InnerClass)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#twisted-involution"><span>twisted_involution</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum,mat-&gt;InnerClass,vec)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#inner-class2"><span>inner_class</span></a></td>
<td><code class="docutils literal"><span class="pre">(RootDatum,string-&gt;InnerClass)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#inner-class3"><span>inner_class</span></a></td>
<td><code class="docutils literal"><span class="pre">(Lie_type,[ratvec],string-&gt;InnerClass)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#id75"><span>=</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass,InnerClass-&gt;bool)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nr-of-real-forms"><span>nr_of_real_forms</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nr-of-dual-real-forms"><span>nr_of_dual_real_forms</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;int)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nr-of-cartan-classes"><span>nr_of_Cartan_classes</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#block-sizes"><span>block_sizes</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#form-names"><span>form_names</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;[string])</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dual-form-names"><span>dual_form_names</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;[string])</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#occurrence-matrix"><span>occurrence_matrix</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;mat)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dual-occurrence-matrix"><span>dual_occurrence_matrix</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#real-form"><span>real_form</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass,int-&gt;RealForm)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#inner-class"><span>inner_class</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;InnerClass)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#form-number"><span>form_number</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quasisplit-form"><span>quasisplit_form</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;RealForm)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#components-rank"><span>components_rank</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;int)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#count-cartans"><span>count_Cartans</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;int)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#operator-2"><span>=</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm,RealForm-&gt;bool)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#kgb-size"><span>KGB_size</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;int)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#base-grading-vector"><span>base_grading_vector</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;ratvec)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cartan-order"><span>Cartan_order</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dual-real-form"><span>dual_real_form</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass,int-&gt;RealForm)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dual-quasisplit-form"><span>dual_quasisplit_form</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass-&gt;RealForm)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#id110"><span>Cartan_class</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass,int-&gt;CartanClass)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cartan-class2"><span>Cartan_class</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm,int-&gt;CartanClass)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#most-split-cartan"><span>most_split_Cartan</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;CartanClass)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#involution3"><span>involution</span></a></td>
<td><code class="docutils literal"><span class="pre">(CartanClass-&gt;mat)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cartan-info"><span>Cartan_info</span></a></td>
<td><code class="docutils literal"><span class="pre">(CartanClass-&gt;(int,int,int),vec,(int,int),(LieType,LieType,LieType))</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#real-forms"><span>real_forms</span></a></td>
<td><code class="docutils literal"><span class="pre">(CartanClass-&gt;[RealForm])</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dual-real-forms"><span>dual_real_forms</span></a></td>
<td><code class="docutils literal"><span class="pre">(CartanClass-&gt;[RealForm])</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#square-classes"><span>square_classes</span></a></td>
<td><code class="docutils literal"><span class="pre">(CartanClass-&gt;[[int]])</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#fiber-partition"><span>fiber_partition</span></a></td>
<td><code class="docutils literal"><span class="pre">(CartanClass,RealForm-&gt;[int])</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#real-form2"><span>real_form</span></a></td>
<td><code class="docutils literal"><span class="pre">(InnerClass,mat,ratvec-&gt;RealForm)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#central-fiber"><span>central_fiber</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;[vec])</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#initial-torus-bits"><span>initial_torus_bits</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealForm-&gt;vec)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#kgb"><span>KGB</span></a></td>
<td><code class="docutils literal"><span class="pre">(RealFrom,int-&gt;KGBElt)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#id108"><span>%</span></a></td>
<td><code class="docutils literal"><span class="pre">(KGBElt-&gt;RealForm,int)</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cartan-class3"><span>Cartan_class</span></a></td>
<td><code class="docutils literal"><span class="pre">(KGBElt-&gt;CartanClass)</span></code></td>
</tr>
</tbody>
</table>
<div class="section" id="classify-involution">
<span id="id70"></span><h3>classify_involution<a class="headerlink" href="#classify-involution" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(mat-&gt;int,int,int)</span></code>: determine type of lattice involution</p>
<p>For any linear involution of <span class="math">\(\mathbb{Z}^n\)</span>, there is a basis consisting of certain vectors that are eigenvectors with eigenvalues 1 or -1 for the involution, and of pairs of vectors that are interchanged by the involution. The numbers of such vectors for each eigenvalue and of interchanged pairs determine the involution up to base change. This function, which requires its argument to be the matrix of an involution, returns these three numbers in the following order: eigenvectors for 1 (compact rank), pairs of interchanged vectors (Complex rank), eigenvectors for -1 (split rank).</p>
</div></blockquote>
</div>
<div class="section" id="inner-class">
<span id="id71"></span><h3>inner_class<a class="headerlink" href="#inner-class" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RootDatum,mat-&gt;InnerClass)</span></code>: inner_class of G from involution</p>
<p>This is the basic function for building a complex reductive group equipped with an involution from the root datum and that involution; the latter is given on the lattice basis of the root datum, and must describe an involutive automorphism of the root datum. The involution is converted to a based root datum involution if necessary, using the Weyl group.</p>
</div></blockquote>
</div>
<div class="section" id="twisted-involution">
<span id="id72"></span><h3>twisted_involution<a class="headerlink" href="#twisted-involution" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum,mat-&gt;InnerClass,vec)</span></code>: inner_class and Weyl word
Build an inner class as the above function, and also return a Weyl word (twisted involution) that expresses the given involution in that inner class. The latter is a reduced word (with Weyl group generators numbered from 0), to be left-multiplied to the distinguished involution.</div></blockquote>
</div>
<div class="section" id="inner-class2">
<span id="id73"></span><h3>inner_class<a class="headerlink" href="#inner-class2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RootDatum,string-&gt;InnerClass)</span></code>: get inner class of G symbolically
Build a complex reductive group directly from a root datum, but compute the distinguished involution from the string describing it symbolically.</div></blockquote>
</div>
<div class="section" id="inner-class3">
<span id="id74"></span><h3>inner_class<a class="headerlink" href="#inner-class3" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(Lie_type,[ratvec],string-&gt;InnerClass)</span></code>: inner class as in Atlas</div></blockquote>
</div>
<div class="section" id="id75">
<span id="id76"></span><h3>=<a class="headerlink" href="#id75" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass,InnerClass-&gt;bool)</span></code>: identity of inner classes</p>
<p>This holds only when both arguments refer to the same inner class creation, in other words it will recognize <code class="docutils literal"><span class="pre">ic=inner_class(real_form(ic,0))</span></code> as true, but any freshly built inner class tests unequal to anything preexisting <code class="docutils literal"><span class="pre">distinguished_involution</span></code>: <code class="docutils literal"><span class="pre">(InnerClass-&gt;mat)</span></code>: involution of the inner class. Extract the distinguished involution of <span class="math">\(X^*\)</span> that defines the inner class dual: <code class="docutils literal"><span class="pre">(InnerClass-&gt;InnerClass)</span></code>: dual inner class for dual complex group</p>
</div></blockquote>
</div>
<div class="section" id="nr-of-real-forms">
<span id="id77"></span><h3>nr_of_real_forms<a class="headerlink" href="#nr-of-real-forms" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(InnerClass-&gt;int)</span></code>: number of real forms in inner class</div></blockquote>
</div>
<div class="section" id="nr-of-dual-real-forms">
<span id="id78"></span><h3>nr_of_dual_real_forms<a class="headerlink" href="#nr-of-dual-real-forms" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(InnerClass-&gt;int)</span></code>: number of dual forms in inner class</div></blockquote>
</div>
<div class="section" id="nr-of-cartan-classes">
<span id="id79"></span><h3>nr_of_Cartan_classes<a class="headerlink" href="#nr-of-cartan-classes" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(InnerClass-&gt;int)</span></code>: total number of Cartans in inner class</div></blockquote>
</div>
<div class="section" id="block-sizes">
<span id="id80"></span><h3>block_sizes<a class="headerlink" href="#block-sizes" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass-&gt;mat)</span></code>: matrix giving the block sizes.</p>
<p>This is essentially the same as the output of &#8216;blocksizes&#8217; in Atlas; the rows of the matrix correspond to real forms for the inner class, and the columns correspond to dual real forms for the inner class.</p>
</div></blockquote>
</div>
<div class="section" id="form-names">
<span id="id81"></span><h3>form_names<a class="headerlink" href="#form-names" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass-&gt;[string])</span></code>: list of names of real forms.</p>
<p>These are the same names used in atlas, describing real Lie algebras</p>
</div></blockquote>
</div>
<div class="section" id="dual-form-names">
<span id="id82"></span><h3>dual_form_names<a class="headerlink" href="#dual-form-names" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass-&gt;[string])</span></code>: list of names of dual real forms.</p>
<p>These are the names for the real forms of the dual InnerClass value</p>
</div></blockquote>
</div>
<div class="section" id="occurrence-matrix">
<span id="id83"></span><h3>occurrence_matrix<a class="headerlink" href="#occurrence-matrix" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass-&gt;mat)</span></code>: real form-Cartan class incidence matrix</p>
<p>For the given inner class, construct a matrix whose rows are parametrized by the real forms, and whose columns are parametrized by the Cartan classes, showing whether (1) or not (0) the Cartan class occurs for the real form</p>
</div></blockquote>
</div>
<div class="section" id="dual-occurrence-matrix">
<span id="id84"></span><h3>dual_occurrence_matrix<a class="headerlink" href="#dual-occurrence-matrix" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(InnerClass-&gt;mat)</span></code>: dual real form-Cartan class matrix. This is like <code class="docutils literal"><span class="pre">occurrence_matrix</span></code>, but with rows representing dual real forms.</div></blockquote>
</div>
<div class="section" id="real-form">
<span id="id85"></span><h3>real_form<a class="headerlink" href="#real-form" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass,int-&gt;RealForm)</span></code>: select a real form from inner class.</p>
<p>The result of form_names describes the valid range and names of real forms; this function actually constructs a real form from the list, selected by its position (starting from 0). The list is always the same for a given inner class (independent of other computations), unlike the list of Cartan classes for a real form as discussed below</p>
<p><code class="docutils literal"><span class="pre">inner_class:</span> <span class="pre">(RealForm-&gt;InnerClass)</span></code>: inner class containing the form</p>
</div></blockquote>
</div>
<div class="section" id="form-number">
<span id="id86"></span><h3>form_number<a class="headerlink" href="#form-number" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RealForm-&gt;int)</span></code>: index of the real form in its inner class</div></blockquote>
</div>
<div class="section" id="quasisplit-form">
<span id="id87"></span><h3>quasisplit_form<a class="headerlink" href="#quasisplit-form" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass-&gt;RealForm)</span></code>: quasisplit form for the inner class</p>
<p>This is the last one in the list of real forms for the fundamental Cartan (number 0 in the list) of the inner class.</p>
</div></blockquote>
</div>
<div class="section" id="components-rank">
<span id="id88"></span><h3>components_rank<a class="headerlink" href="#components-rank" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm-&gt;int)</span></code>: rank of the component group</p>
<p>The group of connected components of the real Lie group defined by a real form is an elementary 2-group (<span class="math">\(\mathbb{Z}/2\mathbb{Z}\)</span> vector space); this function gives its rank, so the number of connected components is 2^components_rank(rf)</p>
</div></blockquote>
</div>
<div class="section" id="count-cartans">
<span id="id89"></span><h3>count_Cartans<a class="headerlink" href="#count-cartans" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm-&gt;int)</span></code>: number of Cartan classes for this real form</p>
<p>The Cartan classes are actually constructed, and remembered, by this command whence its first execution for some real form may take some time</p>
</div></blockquote>
</div>
<div class="section" id="operator-2">
<span id="id90"></span><h3>=<a class="headerlink" href="#operator-2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm,RealForm-&gt;bool)</span></code>: equality of real forms</p>
<p>It means they belong to an identical inner class, and have same form number</p>
</div></blockquote>
</div>
<div class="section" id="kgb-size">
<span id="id91"></span><h3>KGB_size<a class="headerlink" href="#kgb-size" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(RealForm-&gt;int)</span></code>: size of the set <span class="math">\(K\backslash G/B\)</span> for this real form</div></blockquote>
</div>
<div class="section" id="base-grading-vector">
<span id="id92"></span><h3>base_grading_vector<a class="headerlink" href="#base-grading-vector" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm-&gt;ratvec)</span></code>: Offset implicit in torus_bits values</p>
<p>The binary vectors torus_bits for elements of the KGB associated to a real form are relative to a special torus element t0, and this function produces a dominant rational coweight c for which <span class="math">\(\exp(\pi i c)\)</span> equals this t0. The choice of t0 and of c are constant for each &#8220;square class&#8221; of real forms (which are grouped together in the output of print_strong_real for the fundamental Cartan), for which the squares of any of their strong involutions are the same torus element z: the choice of c is subject to <span class="math">\(\exp(2\pi i(c+rho_check))=z\)</span> which reflects <span class="math">\((t0)^2\exp(2\pi i rho_check)=z\)</span>.</p>
<p>Apart from z, the choice of c (or of t0) defines an implicit &#8220;base grading&#8221; of the simple roots at the distinguished involution of the inner class, by the parity of the (integer) pairing of c with the simple root. Here &#8220;odd&#8221; corresponds to grading 0, due to the mentioned rho_check: so c differs by <code class="docutils literal"><span class="pre">rho_check</span></code> from some &#8220;inifinitesimal cocharacter&#8221; g chosen for the real form. A standard choice for c is determined by the base grading for the  weak real form, whence the name of this function. However for real forms synthesized by the function <code class="docutils literal"><span class="pre">real_form&#64;(InnerClass,mat,ratvec)</span></code>, the arguments of that call may determine a different value of z, in which case a different choice for c is made to match it. The choice of c then depends on z only; in particular it will be the same for real forms synthesized using different strong involutions for the same real group, and such groups will test equal.</p>
</div></blockquote>
</div>
<div class="section" id="cartan-order">
<span id="id93"></span><h3>Cartan_order<a class="headerlink" href="#cartan-order" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm-&gt;mat)</span></code>: matrix describing ordering of Cartan classes</p>
<p>The Cartan classes for a given real form form a partially ordered set; this function returns this partial ordering in the form of a square 0-1 matrix.</p>
</div></blockquote>
</div>
<div class="section" id="dual-real-form">
<span id="id94"></span><h3>dual_real_form<a class="headerlink" href="#dual-real-form" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass,int-&gt;RealForm)</span></code>: select a dual real form</p>
<p>This is like real_form, but selects a dual real form for the inner class (whose names are given by <code class="docutils literal"><span class="pre">dual_form_names</span></code>) by index. This is intended for functions that require both a real form and a dual real form for a given inner class; the compatibility between them is tested by a runtime check.</p>
</div></blockquote>
</div>
<div class="section" id="dual-quasisplit-form">
<span id="id95"></span><h3>dual_quasisplit_form<a class="headerlink" href="#dual-quasisplit-form" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(InnerClass-&gt;RealForm)</span></code>: quasisplit dual real form</div></blockquote>
</div>
<div class="section" id="cartan-class">
<span id="cartan-class3"></span><h3>Cartan_class<a class="headerlink" href="#cartan-class" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass,int-&gt;CartanClass)</span></code>: Cartan class selected by number</p>
<p>This selects a Cartan class by number in the list of all Cartan classes for this inner class. The numbering is fixed, and compatible with  the partial ordering on Cartan classes where more split ones are considered greater.</p>
</div></blockquote>
</div>
<div class="section" id="cartan-class2">
<span id="id96"></span><h3>Cartan_class<a class="headerlink" href="#cartan-class2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm,int-&gt;CartanClass)</span></code>: Cartan class selected by number</p>
<p>This selects a Cartan class by number in the list of Cartan classes defined for this real form. The numbering is not the same as when selecting a Cartan class directly from an inner class, unless the real form is quasisplit.</p>
</div></blockquote>
</div>
<div class="section" id="most-split-cartan">
<span id="id97"></span><h3>most_split_Cartan<a class="headerlink" href="#most-split-cartan" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm-&gt;CartanClass)</span></code>: most split Cartan class for form</p>
<p>The most split Cartan class of a given real form is the last one in the list of its Cartan classes, so set <code class="docutils literal"><span class="pre">most_split_Cartan(RealForm</span> <span class="pre">rf)``=``Cartan_class(rf,count_Cartans(rf)-1)</span></code></p>
</div></blockquote>
</div>
<div class="section" id="involution3">
<span id="id98"></span><h3>involution<a class="headerlink" href="#involution3" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(CartanClass-&gt;mat)</span></code>: weight lattice involution for Cartan class</div></blockquote>
</div>
<div class="section" id="cartan-info">
<span id="id99"></span><h3>Cartan_info<a class="headerlink" href="#cartan-info" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(CartanClass-&gt;(int,int,int),vec,(int,int),(LieType,LieType,LieType))</span></code>:</p>
<p>Information about the Cartan class, essentially that given by the output of &#8216;cartan&#8217; in Fokko (except for the final partition corresponding to the real forms for this Cartan class, for which see fiber_partition). The first triple of integers gives in order the number of compact (<span class="math">\(U(1)\)</span>), complex (<span class="math">\(GL(1,\mathbb{C})\)</span>), and split (<span class="math">\(GL(1,\mathbb{R})\)</span>) factors of the real torus defined by this Cartan class. Follows the canonical twisted involution for the Cartan class, a pair of integers giving the number of distinct twisted involutions defining this same Cartan class and their fiber size, and finally the types of the imaginary, real, and complex root subsystems (note the order here).</p>
</div></blockquote>
</div>
<div class="section" id="real-forms">
<span id="id100"></span><h3>real_forms<a class="headerlink" href="#real-forms" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(CartanClass-&gt;[RealForm])</span></code>: list of real forms with given Cartan</p>
<p>Returns a list of the real forms for which this Cartan class occurs</p>
</div></blockquote>
</div>
<div class="section" id="dual-real-forms">
<span id="id101"></span><h3>dual_real_forms<a class="headerlink" href="#dual-real-forms" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(CartanClass-&gt;[RealForm])</span></code>: list Cartan&#8217;s dual real forms</p>
<p>Returns a list of the dual real forms for which this Cartan class occurs</p>
</div></blockquote>
</div>
<div class="section" id="square-classes">
<span id="id102"></span><h3>square_classes<a class="headerlink" href="#square-classes" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(CartanClass-&gt;[[int]])</span></code>: partition real forms by square class</p>
<p>This returns a list of lists of numbers that identify real forms in the inner class. All real forms whose representative strong involutions may square to the same value in the center are grouped together in a sublist (the number of sublists is a power of 2). Each number occurs only in a single sublist, but may be repeated, which indicates that there are mulitple orbits of strong involutions (strong real forms) for the same real form. The value returned represents a part of the print_strong_real output.</p>
</div></blockquote>
</div>
<div class="section" id="fiber-partition">
<span id="id103"></span><h3>fiber_partition<a class="headerlink" href="#fiber-partition" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(CartanClass,RealForm-&gt;[int])</span></code>: identifying part of fiber group</p>
<p>This produces an increasing sequence of integers that characterizes the real form relative to the CartanClass. It describes a part of the adjoint fiber group associated to the Cartan class (an elementary 2-group of rank r equal to the number of compact factors of the real torus in the _adjoint_ group defined by the Cartan class), whose elements are represented by numbers 0 to <span class="math">\(2^r-1\)</span>; as the real form traverses all those for which this Cartan class occurs, the results of the function form a partition of that set of numbers.</p>
</div></blockquote>
</div>
<div class="section" id="real-form2">
<span id="id104"></span><h3>real_form<a class="headerlink" href="#real-form2" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(InnerClass,mat,ratvec-&gt;RealForm)</span></code>: real form from strong real form</p>
<p>Synthesize a real form defined by an involution and a torus factor. With arguments (ic,M,v), the matrix M should define an involution theta in the inner class. The rational vector v, after being made right M-fixed by right multiplication by (M+1)/2, defines a torus element <span class="math">\(\exp(\pi i v)\)</span> whose square must be central, which means that v*alpha must be integral for all (simple) roots alpha. If this holds then theta and torus_factor v together define a strong involution representative. The function returns the strong real form rf identified by that strong involution. It may differ from real_form(ic,form_number(rf)), the standard version of this weak real form; the difference can be seen through the value of base_grading_vector(rf), and in the RealForm equality test (because of this distinction, one may consider the result to represent a strong real form). Real forms produced by this function are said to be synthesized (rather than selected). A subsequent call KGB_elt(rf,theta,v) should always produce a valid KGB element x. The grading of the imaginary roots alpha for theta defined by this x will be given by the parity of <span class="math">\(&lt; v+\check\rho_i, \alpha &gt;\)</span>, where <span class="math">\(\check\rho_i\)</span> is half the sum of the positive imaginary coroots for M (its presence in the formula ensures that v=0 is always valid, and grades all simple-imaginary roots as noncompact). This grading is the most tangible aspect of (theta,v), but only determines the weak real form, and may fail to identify a unique KGB element x; this function and the mentioned instance of KGB_elt are faithful beyond just reconstructing the correct grading.</p>
</div></blockquote>
</div>
<div class="section" id="central-fiber">
<span id="id105"></span><h3>central_fiber<a class="headerlink" href="#central-fiber" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm-&gt;[vec])</span></code>: Set of torus bits not affecting any gradings</p>
<p>These are binary vectors that can be added to <code class="docutils literal"><span class="pre">|torus_bits|</span></code> of KGB elements in the fundamental fiber to get another KGB element giving the same status (including compactness of imaginary roots) to every simple root; adding any of these values to torus bits defines an automorphism of the KGB structure</p>
</div></blockquote>
</div>
<div class="section" id="initial-torus-bits">
<span id="id106"></span><h3>initial_torus_bits<a class="headerlink" href="#initial-torus-bits" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealForm-&gt;vec)</span></code>: Torus bits for initial KGB element</p>
<p>This is a test function, computing what should be the torus bits of KGB(G,0) independently of what is currently set in the implementation. They could differ from reality by an element of <code class="docutils literal"><span class="pre">|central_fiber(G)|</span></code>. This function can be removed once the same computation will actually replace the implemented choice for the torus bits with which the KGB construction starts off.</p>
</div></blockquote>
</div>
<div class="section" id="kgb">
<span id="id107"></span><h3>KGB<a class="headerlink" href="#kgb" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">(RealFrom,int-&gt;KGBElt)</span></code>: select a KGB element x among those of a real form</p>
<p>The call <code class="docutils literal"><span class="pre">KGB(i,rf)</span></code> selects the element in line i of the <code class="docutils literal"><span class="pre">print_KGB(rf)</span></code> output.</p>
</div></blockquote>
</div>
<div class="section" id="id108">
<span id="id109"></span><h3>%<a class="headerlink" href="#id108" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(KGBElt-&gt;RealForm,int)</span></code>: real form and number; inverse of <code class="docutils literal"><span class="pre">KGB&#64;(RealForm,int)</span></code></div></blockquote>
</div>
<div class="section" id="id110">
<span id="id111"></span><h3>Cartan_class<a class="headerlink" href="#id110" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><code class="docutils literal"><span class="pre">(KGBElt-&gt;CartanClass)</span></code>: the Cartan class for the KGB element</div></blockquote>
<p>involution: (KGBElt-&gt;mat): the involution of X^* associated to the KGB element</p>
<p>length: (KGBElt-&gt;int): length of the element within its KGB set</p>
<dl class="docutils">
<dt>status: (int,KGBElt-&gt;int): status of generator on KGB element, scale 0..4</dt>
<dd>Encoding 0: Complex descent, 1: imaginary compact, 2: real,
3: imaginary non-compact, 4: Complex ascent</dd>
<dt>status: (vec,KGBElt-&gt;int): status of any root on KGB element, scale 0..4</dt>
<dd>The value status(alpha,x) gives the status of the root alpha at x; the
encoding of statuses is the same as for the function status&#64;(int,KGBElt)</dd>
<dt>cross: (int,KGBElt-&gt;KGBElt): cross action for (posrootnr,KGB element)</dt>
<dd>Returns result of cross action by root reflection of the given KGB element</dd>
<dt>Cayley: (int,KGBElt-&gt;KGBElt): Cayley transform for (posrootnr,KGB element)</dt>
<dd>Returns either the Cayley transform or an inverse Cayley transform of the
KGB element through the given positive root, or returns that element itself
when neither is defined. If defined, one can find which it is using status,
and whether there is a second inverse Cayley transform can be found out by
applying cross action to the result; it either returns the same result,
which signifies a single-value inverse Cayley, or else the second value</dd>
<dt>twist: (KGBElt-&gt;KGBElt): twist of KGB element x, useful for Hermitian dual</dt>
<dd>This is defined by conjugation of x by the distinguished involution delta</dd>
<dt>torus_factor: (KGBElt-&gt;ratvec): coweight for KGB element, twice that in print_X</dt>
<dd>This is a theta^t stable rational vector v with integral evaluations on
all imaginary roots; interpreted modulo the image of 1+theta^t acting
on X_*, so in particular modulo (2Z)^n. For an imaginary root alpha
the scalar product &lt; v + checkrho_i , alpha &gt; determines whether alpha
is compact (if even) or noncompact (if odd). Together with the inner class
and the invlution, this value completely characterises the KGB element (and
its real form), and it can be reconstructed using the KGB_elt function below.</dd>
<dt>torus_bits: (KGBElt-&gt;vec): torus part of KGB element as vector of 0,1 values</dt>
<dd>A vector of size the rank that distinguishes between different KGB elements
at the same involution, in the format used internally. From this the value
torus_factor(x) is computed using base_grading_vector(rf)-torus_bits(x), for
the real form rf of x, which value is then symmetrized for theta^t.</dd>
<dt>KGB_elt: (RealForm,mat,ratvec): KGB element defined by rational coweight</dt>
<dd>This function finds a KGB element x such that real_form(x), involution(x),
and torus_factor(x) match the values (rf,M,v) given as arguments. The
interpretation for the (involution) matrix M and rational (coweight) vector
v are as for real_form&#64;(InnerClass,mat,ratvec); moreover rf should be equal
to the real form returned (for this inner class) by real_form(ic,M,v), and
the difference v-base_grading_vector(rf) must be an integer vector. There is
then at most one KGB element x for rf such that torus_factor(x) is congruent
to v modulo the image of ^M+1 (i.e., M+1 applied on right), which x is then
returned by this function (if no such x is found, an error is signaled).</dd>
</dl>
<p>operator = : (KGBElt,KGBElt): equality of elements of a same KGB set</p>
<p>block: (RealForm,RealForm-&gt;Block): construct tradiational atlas block</p>
<p>%: (Block-&gt;RealForm,RealForm): decompose block, inverse of &#8216;block&#8217;</p>
<p>#: (Block-&gt;int): number of elements of block</p>
<p>element: (Block,int-&gt;KGBElt,KGBElt): KGB and dual KGB values for block element</p>
<dl class="docutils">
<dt>index (Block,KGBElt,KGBElt-&gt;int): index in block, from KGB, dual KGB components</dt>
<dd>This is the inverse of the map defined by element&#64;(Block,int): given a
compatible pair of a KGB element x and a dual KGB element y, it returns the
index in the block of the corresponding element. For efficiency reasons the
function requires the containing block to be supplied as first argument; if
needed, block(real_form(x),dual_real_form(real_form(y))) computes the block</dd>
</dl>
<p>dual: (Block-&gt;Block): dual block, with real form and dual real form swapped</p>
<dl class="docutils">
<dt>status: (int,Block,int-&gt;): status at a block element of a simple reflection</dt>
<dd>For s the index of a reflection, and i the index of an element of block b,
status(s,b,i) gives according to the codes 0:C-, 1:ic, 2:r1, 3:r2,  4:C+,
5: rn, 6:i1, 7:i2. Note that the descents s have status(b,i,s)&lt;4</dd>
</dl>
<p>param: (KGBElt,vec,ratvec-&gt;Param): form parameter from (x,lambda-rho,nu)</p>
<p>operator % : (Param-&gt;KGBElt,vec,ratvec): recover (x,lambda-rho,nu) from param</p>
<p>real_form: (Param-&gt;RealForm): recover the real form from a Param value</p>
<dl class="docutils">
<dt>infinitesimal_character: (Param-&gt;ratvec): infinitesimal character of parameter</dt>
<dd>This is actually a representative of the infinitesimal character, given by
gamma = ((1+theta)lambda+(1-theta)nu)/2. The meaning of the x component of
the parameter is determined by its position relative to this representative
gamma, so to find the x value uniquely associated to the representation for
the parameter, one should apply the function &#8216;dominant&#8217; to the parameter
first, after which the value of infinitesimal_character is indeed dominant</dd>
<dt>is_standard: (Param-&gt;bool): whether parameter defines a standard module</dt>
<dd>This is true whenever gamma is dominant relative to the imaginary roots</dd>
<dt>is_zero: (Param-&gt;bool): whether parameter defines a zero standard module</dt>
<dd>True whenever gamma is singular on a compact (for x) simple-imaginary root</dd>
<dt>is_final: (Param-&gt;bool): whether parameter defines a final standard module</dt>
<dd>False whenever associated standard representation is combination of others
on more compact Cartans by a Hecht-Schmid identity. So is_final(p) is true
provided no real coroots for which gamma is singular satisfy the parity
condition. Note: one could still have is_zero(p); this needs a separate test.</dd>
<dt>dominant: (Param-&gt;Param): make gamma dominant and do singular complex descents</dt>
<dd>This brings the parameter p into standard form, in which it will appear when
p occurs in a ParamPol (which also requires is_final(p) and not is_zero(p)).</dd>
<dt>operator = <span class="classifier-delimiter">:</span> <span class="classifier">(Param,Param-&gt;bool): test equivalence of parameters</span></dt>
<dd>This is implemented by applying dominant and testing identity of all
three components x, lambda (defined modulo (1-theta_x)X^*) and nu.</dd>
<dt>cross: (int,Param-&gt;Param): cross action for (Weyl group generator,parameter)</dt>
<dd>This first argument indexes (starting at 0) a simple root for the subsystem
for the given parameter p: integrality_datum(infinitesimal_character(p))</dd>
<dt>Cayley: (int,Param-&gt;Param): Cayley transform for (Weyl generator,parameter)</dt>
<dd>If (and only if) the transform is undefined it returns the same parameter
Find out possible second value by applying cross action to the result</dd>
<dt>inv_Cayley: (int,Param-&gt;Param): inverse Cayley transform</dt>
<dd>If (and only if) the inverse transform is undefined it returns the same
parameter. Find out possible second value of invere transform by applying
cross action to the result, which either produces it or else fixes result</dd>
</dl>
<p>cross: (vec,Param-&gt;Param): cross action for (root,parameter)</p>
<dl class="docutils">
<dt>Cayley: (vec,Param-&gt;Param): Cayley transform for (root,parameter)</dt>
<dd>These two functions should do the same as the three before, but taking the
root in coordinates, and combining the Cayley/inverse Cayley into one
function (whichever is defined is applied, or else the parameter returned).
The implementation is quite independent however, so comparison is useful.</dd>
</dl>
<p>twist: (Param-&gt;Param): twist the parameter by the distinguihed involution</p>
<p>orientation_nr: (Param-&gt;int): the orientation number</p>
<p>reducibility_points: (Param-&gt;[rat]): the 0&lt;t&lt;=1 with I(x,lambda,tnu) reducible</p>
<p>print_block: (Param-&gt;): print (nonintegral) block generated from parameter</p>
<dl class="docutils">
<dt>block: (Param-&gt;[Param],int): return block as list of parameters, and index</dt>
<dd>The second component is the index into the first of the original parameter.</dd>
<dt>partial_block: (Param-&gt;[Param]): return partial block as list of parameters</dt>
<dd>This is the Bruhat interval of the block below the given parameter,
sorted by length and including the given parameter as final element</dd>
</dl>
<p>length: (Param-&gt;int): the length of a parameter within its block</p>
<dl class="docutils">
<dt>KL_block: (Param-&gt;[Param],int,mat,[vec],vec,vec,mat): block, raw_KL, and more</dt>
<dd>This combines block with the Kazhdan-Lustzig table for the block appended,
and two more values that allow cumulation to be performed. The two values of
block are followed by three values in the format of raw_KL below: a matrix
of indices into the following list of polynomials, coded as a list of
coefficient vectors, then a list of indices where the length function
increases. Finally follow a vector with indices of the &#8220;surviving&#8221; block
elements, and a matrix whose rows correspond to those survivors, its columns
to all block elements, and whose the entries gives the coefficients by which
each the block element (column) contributes to the surviving element (row),
with a sign given by the parity of their length difference. Here &#8220;surviving&#8221;
refers to the result of applying a translation functor to a standard module,
namely a functor from regular infinitesimal character to the current
(possibly) singular infinitesimal character. Thus one can transform the
given KL matrix (computed at regular infinitesimal character) to one at the
actual block by selecting only the columns whose index is among the
survivors, and multiplying the resulting matrix on the left by the
contibution-coefficient matrix (the final component this function returns).</dd>
<dt>partial_KL_block: (Param-&gt;[Param],mat,[vec],vec,vec,mat) partial KL_block</dt>
<dd>This function relates to KL_block as partial_block relates to block. The
first component of the result is the Bruhat interval as in partial_block,
and all other components are the same is in KL_block (except that the now
superfluous second component of KL_block is omitted), but with the two vec
components filtered so as to be indexed by the Bruhat interval indices only.</dd>
</dl>
<p>operators =, != : (Split-&gt;bool): test split integer against Split:(0,0)
operators =, != : (Split,Split-&gt;bool): equality/inequality of split integers
operator + : (Split,Split-&gt;Split): addition of split integers
operator - : (Split,Split-&gt;Split): subtraction of split integers
operator - : (Split-&gt;Split): negation of a split integer
operator * : (Split,Split-&gt;Split): multiplication of split integers
operator % : (Split,int,int): decomposition of split integer into components</p>
<p>null_module: (RealForm-&gt;ParamPol): empty sum of parameters for the real form
real_form: (ParamPol-&gt;RealForm): recover the real form from a ParamPol value
operator # : (ParamPol-&gt;int): number of nonzero terms of the formal sum
operators =, != : (ParamPol-&gt;bool): test virtual module for being zero
operators =, != : (ParamPol,ParamPol-&gt;bool): test virtual modules for equality
operator +, - : (ParamPol,Param-&gt;ParamPol): add/subtract parameter to formal sum
operator + : (ParamPol,(Split,Param)-&gt;ParamPol): add parameter with coefficient
operator + : (ParamPol,[(Split,Param)]-&gt;ParamPol): add terms to formal sum
operators +, - : (ParamPol,ParamPol-&gt;ParamPol): addition/subtraction formal sums
operator * : (int,ParamPol-&gt;ParamPol): integer multiple of a formal sum
operator * : (Split,ParamPol-&gt;ParamPol): split integer multiple of a formal sum
last_term: (ParamPol-&gt;Split,Param): highest term (for #x(p)) of non-empty module
first_term: (ParamPol-&gt;Split,Param): lowest term (for #x(p)) of non-empty module</p>
<dl class="docutils">
<dt>K_type_formula: (Param-&gt;ParamPol) Express K-type in terms of standardrepns|_K</dt>
<dd>The argument parameter is interpreted as giving an irreducible module; its
restriction to K is expressed as linear combination of restrictions to K of
standard representations, and a polynomial giving their parameters returned.</dd>
<dt>branch: (Param,int-&gt;ParamPol) Find K-types of standardrepn up to given limit</dt>
<dd>The first argument is taken as standard representation, and is interpreted
as restricted to K (the nu component is replaced by a zero vector), while
the argument second is a bound on the height; the result should be
interpreted as linear combination of K-types, each standard final parameter
term standing for its lowest K-type.</dd>
</dl>
<p>to_canonical: (Param-&gt;Param) Move parameter to canonical fiber (making nu=0)</p>
<dl class="docutils">
<dt>height: (Param-&gt;int) W-invariant height measure standardrepn restricted to K</dt>
<dd>This is the sum of absolute values of the scalar products of (1+theta)lambda
and the positive coroots; it ignores the nu component of the parameter.
This is the same function as used in branch to compare with the given limit.</dd>
<dt>deform: (Param-&gt;ParamPol): compute deformation terms when nu decreases</dt>
<dd>The non-integral block for the parameter and its KL polynomials are
computed, from which the deformation terms involing other members of the
block are computed. They are returned as a formal sum of paramters with
split integer coefficients, which are in fact integer multiples of (1-s).</dd>
<dt>full_deform: (Param-&gt;ParamPol): perform deformation all the way to nu=0</dt>
<dd>This is like deform, but recursively deforms all new terms produced as long
as they do not have nu=0; all terms in the result therefore have nu=0.</dd>
<dt>KL_sum_at_s: (Param-&gt;ParamPol): signed sum of KL polynomials at s, fixed y</dt>
<dd>Computes sum_{xleq y}(-1)^{l(y)-l(x)}P_{x,y}[q:=s].x where y is the block
element of the parameter, and the sum is over other block elements x.</dd>
<dt>raw_KL: (Block-&gt;mat,[vec],vec): Kazhdan-Lusztig data for block, raw form</dt>
<dd>The call raw_KL(b) produces a matrix of numbers identifying polynomials, a
list of those polynomials in the form of coefficient vectors, and a sequence
of length boundaries that allow deducing the &#8220;lengths&#8221; of the integers used
to index the matrix. These integers identify block elements for the block
print_block(b). If (M,L,len)=raw_KL(b), and v,w are integers identifying
block elements, then the vector L[M[v,w]] gives the coefficients of the KL
polynomial P_{v,w}. The length of v is the lergest index i such that
len[i]&lt;=v, so the length difference between v and w is the number of indices
with v&lt;len[i]&lt;=w.</dd>
<dt>dual_KL: (Block-&gt;mat,[vec],vec): dual KL polynomials (Q_{x,y}) for block</dt>
<dd>This is like raw_KL, but computes the polynomials Q instead of P. The
indexing of the block is the same as for the polynomials P, so up to length
signs, the matrix should be the inverse of the P matrix. The length stops
are provided as final value, as in raw_KL; these are for the _same_ block.</dd>
<dt>print_gradings: (CartanClass,RealForm-&gt;): print gradings defined by real form</dt>
<dd>This more or less gives the output of the &#8216;gradings&#8217; command in the Atlas
software, for the selected real form. The type of the imaginary root system
is printed, with the numbers of the roots that span this root subsytem as
simple roots, in the Bourbaki ordering for its type. Then for each element
in the list produced by fiber_part for the same arguments, the grading of
the imaginary root system is given as a sequence of bits 0 (compact) or 1
(non-compact), to be interpreted on the simple roots in the given order, and
extended to the whole imaginary root subsystem as a Z/2Z grading.</dd>
</dl>
<p>print_real_Weyl: (RealForm,CartanClass-&gt;)
print_strong_real: (CartanClass-&gt;)</p>
<p>print_block: (Block-&gt;):
print_blocku: (Block-&gt;):
print_blockd: (Block-&gt;):
print_blockstabilizer: (Block,CartanClass-&gt;):
print_KGB: (RealForm-&gt;):
print_X: (InnerClass-&gt;):
print_KL_basis: (Block-&gt;):
print_prim_KL: (Block-&gt;):
print_KL_list: (Block-&gt;):
print_W_cells: (Block-&gt;):
print_W_graph: (Block-&gt;):</p>
<p>These commands give the output of the corresponding commands of &#8216;atlas&#8217;.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../source_library.html" class="btn btn-neutral float-right" title="Source Code Library" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="operators.html" class="btn btn-neutral" title="Basic Operators" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, atlasofliegroups.org.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.6',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>atlas: atlas::abelian Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="e8dynkintransparent.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">atlas
   &#160;<span id="projectnumber">0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceatlas.html">atlas</a></li><li class="navelem"><a class="el" href="namespaceatlas_1_1abelian.html">abelian</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">atlas::abelian Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classatlas_1_1abelian_1_1Homomorphism.html">Homomorphism</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae45222c388c53e198b5bbf8dce6897c7"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a></td></tr>
<tr class="memdesc:ae45222c388c53e198b5bbf8dce6897c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">element of Abelian group, compact repr.  <a href="#ae45222c388c53e198b5bbf8dce6897c7">More...</a><br /></td></tr>
<tr class="separator:ae45222c388c53e198b5bbf8dce6897c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b056e41db578caeea19d8242128f25c"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a7b056e41db578caeea19d8242128f25c">GrpNbrList</a></td></tr>
<tr class="separator:a7b056e41db578caeea19d8242128f25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad457a581cf4d41d9680ce0ee44c70ecf"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; unsigned long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a></td></tr>
<tr class="memdesc:ad457a581cf4d41d9680ce0ee44c70ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">group element, array repr.  <a href="#ad457a581cf4d41d9680ce0ee44c70ecf">More...</a><br /></td></tr>
<tr class="separator:ad457a581cf4d41d9680ce0ee44c70ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ee67347bf28d14f7ae49a81ade36c4"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a94ee67347bf28d14f7ae49a81ade36c4">GrpArrList</a></td></tr>
<tr class="separator:a94ee67347bf28d14f7ae49a81ade36c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3a6c8121d843828cdec56e0139b826"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; unsigned long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a8a3a6c8121d843828cdec56e0139b826">GroupType</a></td></tr>
<tr class="separator:a8a3a6c8121d843828cdec56e0139b826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5410de1096701654a3e7a75a8ec648b4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classatlas_1_1matrix_1_1Matrix__base.html">matrix::Matrix_base</a>&lt; unsigned long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a5410de1096701654a3e7a75a8ec648b4">Endomorphism</a></td></tr>
<tr class="separator:a5410de1096701654a3e7a75a8ec648b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a164d1e80aef6a6c911cfae15c1257c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a164d1e80aef6a6c911cfae15c1257c70">basis</a> (std::vector&lt; <a class="el" href="classatlas_1_1matrix_1_1Vector.html">matrix::Vector</a>&lt; int &gt; &gt; &amp;b, const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;B, const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;<a class="el" href="classA.html">A</a>)</td></tr>
<tr class="separator:a164d1e80aef6a6c911cfae15c1257c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08052d50afb4c1ed89f9bbd4eab7772d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a08052d50afb4c1ed89f9bbd4eab7772d">coset</a> (<a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;C, const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;B, <a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a> x, const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;<a class="el" href="classA.html">A</a>)</td></tr>
<tr class="separator:a08052d50afb4c1ed89f9bbd4eab7772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e9c3c736d2124c041ad073e8ed1014"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a06e9c3c736d2124c041ad073e8ed1014">cycGenerators</a> (const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;<a class="el" href="classA.html">A</a>)</td></tr>
<tr class="separator:a06e9c3c736d2124c041ad073e8ed1014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20453ae10b1bc181c42f6e9eff4653ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a20453ae10b1bc181c42f6e9eff4653ff">generateSubgroup</a> (<a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;B, <a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a> x, const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;<a class="el" href="classA.html">A</a>)</td></tr>
<tr class="separator:a20453ae10b1bc181c42f6e9eff4653ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73596e57fd7535bf1a6c4488fa8412fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a73596e57fd7535bf1a6c4488fa8412fa">generators</a> (<a class="el" href="namespaceatlas_1_1abelian.html#a7b056e41db578caeea19d8242128f25c">GrpNbrList</a> &amp;gen, const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;B, const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;<a class="el" href="classA.html">A</a>)</td></tr>
<tr class="separator:a73596e57fd7535bf1a6c4488fa8412fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fc62d7e3dcd3210814230c81cbf95a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a02fc62d7e3dcd3210814230c81cbf95a">isElementaryAbelian</a> (const std::vector&lt; unsigned long &gt; &amp;c)</td></tr>
<tr class="separator:a02fc62d7e3dcd3210814230c81cbf95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fe4e6d1f0a4f67bd554fc2df7d825c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#af8fe4e6d1f0a4f67bd554fc2df7d825c">quotReps</a> (const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;B, const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;<a class="el" href="classA.html">A</a>)</td></tr>
<tr class="separator:af8fe4e6d1f0a4f67bd554fc2df7d825c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625b4619f363ee7c63bd696e7228ceb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a625b4619f363ee7c63bd696e7228ceb2">to_array</a> (<a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a> &amp;a, <a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a> x, const <a class="el" href="namespaceatlas_1_1abelian.html#a8a3a6c8121d843828cdec56e0139b826">GroupType</a> &amp;t)</td></tr>
<tr class="separator:a625b4619f363ee7c63bd696e7228ceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565eb25ebf6c4e8c3d7b1d858f28ee45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a565eb25ebf6c4e8c3d7b1d858f28ee45">to_array</a> (<a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a> &amp;a, const <a class="el" href="classatlas_1_1matrix_1_1Vector.html">matrix::Vector</a>&lt; int &gt; &amp;<a class="el" href="graph_8cpp.html#a796e5c390de2ad622ad0fdd3d12a4c07">v</a>, const <a class="el" href="namespaceatlas_1_1abelian.html#a8a3a6c8121d843828cdec56e0139b826">GroupType</a> &amp;t)</td></tr>
<tr class="separator:a565eb25ebf6c4e8c3d7b1d858f28ee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293f4903df494ad6c04ad36509349b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a293f4903df494ad6c04ad36509349b31">toEndomorphism</a> (<a class="el" href="namespaceatlas_1_1abelian.html#a5410de1096701654a3e7a75a8ec648b4">Endomorphism</a> &amp;<a class="el" href="axis_8cpp.html#af017b5029e4109d3876818aa6c57f1d2">e</a>, const <a class="el" href="classatlas_1_1matrix_1_1PID__Matrix.html">matrix::PID_Matrix</a>&lt; int &gt; &amp;q, const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;<a class="el" href="classA.html">A</a>)</td></tr>
<tr class="separator:a293f4903df494ad6c04ad36509349b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57162aa0f041de2eaa63b13b454c6b19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a57162aa0f041de2eaa63b13b454c6b19">to_GrpNbr</a> (const <a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a> &amp;a, const <a class="el" href="namespaceatlas_1_1abelian.html#a8a3a6c8121d843828cdec56e0139b826">GroupType</a> &amp;t)</td></tr>
<tr class="separator:a57162aa0f041de2eaa63b13b454c6b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cd49965f0f334bb496cf27cf49568b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#a78cd49965f0f334bb496cf27cf49568b">transpose</a> (<a class="el" href="namespaceatlas_1_1abelian.html#a5410de1096701654a3e7a75a8ec648b4">Endomorphism</a> &amp;<a class="el" href="axis_8cpp.html#af017b5029e4109d3876818aa6c57f1d2">e</a>, const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;<a class="el" href="classA.html">A</a>)</td></tr>
<tr class="separator:a78cd49965f0f334bb496cf27cf49568b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13ac20f8ac76d6dbc4a5a6e85f2b55c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceatlas_1_1abelian.html#ad13ac20f8ac76d6dbc4a5a6e85f2b55c">isElementaryAbelian</a> (const std::vector&lt; <a class="el" href="namespaceatlas_1_1arithmetic.html#ab4c10bf03a557d26bc512c4771916f41">arithmetic::Denom_t</a> &gt; &amp;)</td></tr>
<tr class="separator:ad13ac20f8ac76d6dbc4a5a6e85f2b55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5410de1096701654a3e7a75a8ec648b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classatlas_1_1matrix_1_1Matrix__base.html">matrix::Matrix_base</a>&lt;unsigned long&gt; <a class="el" href="namespaceatlas_1_1abelian.html#a5410de1096701654a3e7a75a8ec648b4">atlas::abelian::Endomorphism</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a3a6c8121d843828cdec56e0139b826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;unsigned long&gt; <a class="el" href="namespaceatlas_1_1abelian.html#a8a3a6c8121d843828cdec56e0139b826">atlas::abelian::GroupType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad457a581cf4d41d9680ce0ee44c70ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;unsigned long&gt; <a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">atlas::abelian::GrpArr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>group element, array repr. </p>

</div>
</div>
<a class="anchor" id="a94ee67347bf28d14f7ae49a81ade36c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a>&gt; <a class="el" href="namespaceatlas_1_1abelian.html#a94ee67347bf28d14f7ae49a81ade36c4">atlas::abelian::GrpArrList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae45222c388c53e198b5bbf8dce6897c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">atlas::abelian::GrpNbr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element of Abelian group, compact repr. </p>

</div>
</div>
<a class="anchor" id="a7b056e41db578caeea19d8242128f25c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a>&gt; <a class="el" href="namespaceatlas_1_1abelian.html#a7b056e41db578caeea19d8242128f25c">atlas::abelian::GrpNbrList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a164d1e80aef6a6c911cfae15c1257c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atlas::abelian::basis </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classatlas_1_1matrix_1_1Vector.html">matrix::Vector</a>&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: writes A/B in canonical form.</p>
<p>Explanation: we see the current group <a class="el" href="classA.html">A</a> as a quotient of Z^d, where d is the rank of <a class="el" href="classA.html">A</a>, and the generators of the kernel are multiples of the standard basis vectors given by d_type. The bitmap |B| specifies a subgroup by generators through the |GrpNbr| encoding. Then we wish to write the quotient A/B in canonical form (i.e., as a product of cyclic groups with cardinalities dividing each other.) For this, we put in b a scaled Smith normal basis for the inverse image of B in Z^d.</p>
<p>Note that <a class="el" href="classA.html">A</a> is not necessarily in canonical form, so even when B is the trivial subgroup this might yield a basis rather different from the kernel basis. </p>

</div>
</div>
<a class="anchor" id="a08052d50afb4c1ed89f9bbd4eab7772d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atlas::abelian::coset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: puts in C the coset x+B in <a class="el" href="classA.html">A</a>.</p>
<p>Precondition: C.capacity() == A.order();</p>
<p>NOTE : this is a straightforward implementation, shifting elements of B individually. </p>

</div>
</div>
<a class="anchor" id="a06e9c3c736d2124c041ad073e8ed1014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp; atlas::abelian::cycGenerators </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: returns a reference to a bitmap containing exactly one generator for each cyclic subgroup of <a class="el" href="classA.html">A</a>.</p>
<p>We simply set all bits, then traverse all elements and whenever a bit is set we clear the bits of all elements that generate the same cyclic subgroup as it, namely its multiples by a number relatively prime to its order in |A|. This uses that iterators over a |bitmap::BitMap| adapt to changes to the underlying bitmap during traversal, unlike |bitset::BitSet::iterator|s.</p>
<p>NOTE: it is expected that this function will typically be called repeatedly for the same group. The bitmap is constructed on the first call for the given group, following the principle of lazy evaluation. </p>

</div>
</div>
<a class="anchor" id="a20453ae10b1bc181c42f6e9eff4653ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atlas::abelian::generateSubgroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: transforms B into the subgroup generated by B and x in <a class="el" href="classA.html">A</a>.</p>
<p>NOTE : this is a simple-minded implementation; we do not aim for speed. </p>

</div>
</div>
<a class="anchor" id="a73596e57fd7535bf1a6c4488fa8412fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atlas::abelian::generators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceatlas_1_1abelian.html#a7b056e41db578caeea19d8242128f25c">GrpNbrList</a> &amp;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: puts in gen a list of generators of the subgroup B. </p>

</div>
</div>
<a class="anchor" id="ad13ac20f8ac76d6dbc4a5a6e85f2b55c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atlas::abelian::isElementaryAbelian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceatlas_1_1arithmetic.html#ab4c10bf03a557d26bc512c4771916f41">arithmetic::Denom_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a02fc62d7e3dcd3210814230c81cbf95a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atlas::abelian::isElementaryAbelian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if c is all twos. </p>

</div>
</div>
<a class="anchor" id="af8fe4e6d1f0a4f67bd554fc2df7d825c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> atlas::abelian::quotReps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1bitmap_1_1BitMap.html">bitmap::BitMap</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a625b4619f363ee7c63bd696e7228ceb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atlas::abelian::to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceatlas_1_1abelian.html#a8a3a6c8121d843828cdec56e0139b826">GroupType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: puts the array-form of x in a.</p>
<p>Precondition: x is representable for t (x &lt; prod t[i]); otherwise the result is the expression of x modulo that product.</p>
<p>Explanation: the array-form (relative to type) is the unique expression of x in the variable-radix base defined by type. </p>

</div>
</div>
<a class="anchor" id="a565eb25ebf6c4e8c3d7b1d858f28ee45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atlas::abelian::to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1matrix_1_1Vector.html">matrix::Vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceatlas_1_1abelian.html#a8a3a6c8121d843828cdec56e0139b826">GroupType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: reduces v mod d_type.</p>
<p>The only difficulty is to make sure that negative values are reduced in the way that we want.</p>
<p>Precondition: a is set to v.size(); </p>

</div>
</div>
<a class="anchor" id="a57162aa0f041de2eaa63b13b454c6b19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceatlas_1_1abelian.html#ae45222c388c53e198b5bbf8dce6897c7">GrpNbr</a> atlas::abelian::to_GrpNbr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceatlas_1_1abelian.html#ad457a581cf4d41d9680ce0ee44c70ecf">GrpArr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceatlas_1_1abelian.html#a8a3a6c8121d843828cdec56e0139b826">GroupType</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: returns the number-form of a.</p>
<p>Precondition: a is representable as a GrpNbr; </p>

</div>
</div>
<a class="anchor" id="a293f4903df494ad6c04ad36509349b31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atlas::abelian::toEndomorphism </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceatlas_1_1abelian.html#a5410de1096701654a3e7a75a8ec648b4">Endomorphism</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1matrix_1_1PID__Matrix.html">matrix::PID_Matrix</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: transforms q into the corresponding Endomorphism.</p>
<p>This just involves rewriting the coeficients as unsigned longs modulo the type factors. </p>

</div>
</div>
<a class="anchor" id="a78cd49965f0f334bb496cf27cf49568b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void atlas::abelian::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceatlas_1_1abelian.html#a5410de1096701654a3e7a75a8ec648b4">Endomorphism</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classatlas_1_1abelian_1_1FiniteAbelianGroup.html">FiniteAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synopsis: transposes the endomorphism e.</p>
<p>This is more subtle than one might think; the main point is that when m|n, the transpose of the canonical map Z/nZ -&gt; Z/mZ is the injection Z/mZ -&gt; Z/nZ which takes 1 to n/m. In general, any map Z/nZ -&gt; Z/mZ factors thru Z/dZ, where d = gcd(m,n), so it is a multiple of the map defined by 1 -&gt; m/d; the transpose is the same multiple of 1 -&gt; n/d.</p>
<p>NOTE: this implementation works for homomorphisms between different groups just as well (except that one needs two grouptypes then.) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
